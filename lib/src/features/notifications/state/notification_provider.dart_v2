import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:pzdeals/src/models/index.dart';
import 'package:pzdeals/src/services/notifications_service.dart';
import 'package:pzdeals/src/state/auth_user_data.dart';
import 'package:pzdeals/src/utils/helpers/appbadge.dart';

final notificationsProvider =
    ChangeNotifierProvider<NotificationListNotifier>((ref) {
  final authState = ref.watch(authUserDataProvider);
  if (authState.isAuthenticated) {
    return NotificationListNotifier(userUID: authState.userData?.uid ?? '');
  } else {
    return NotificationListNotifier();
  }
});

class NotificationListNotifier extends ChangeNotifier {
  final NotificationService _notifService = NotificationService();
  final _firestoreDb = FirebaseFirestore.instance;

  List<String> _notificationIdsForDismissal = [];

  String _boxName = 'notifications';
  int pageNumber = 1;
  bool _isLoading = false;
  String _userUID = '';
  int _unreadCount = 0;
  bool _hasNotification = false;

  List<NotificationData> _notifications = [];
  List<DocumentSnapshot> _notifData = [];
  List<NotificationData> _notificationForDeletion = [];

  bool get isLoading => _isLoading;
  List<NotificationData> get notifications => _notifications;
  int get unreadCount => _unreadCount;
  List<NotificationData> get notificationForDeletion =>
      _notificationForDeletion;
  bool get hasNotification => _hasNotification;

  void setUserUID(String uid) {
    debugPrint('setUserUID called with $uid');
    _userUID = uid;
    _boxName = '${_userUID}_notifications';
    // _loadBookmarks();
  }

  NotificationListNotifier({String userUID = ''}) {
    setUserUID(userUID);
    if (_userUID.isNotEmpty) {
      // loadNotifications();
      getUnreadNotificationsCountFromStream(_userUID);
    }
  }

  Future<void> setDismissed(String notifId, bool isDismissed) async {
    await _firestoreDb
        .collection('notifications')
        .doc(_userUID)
        .collection('notification')
        .where('id', isEqualTo: notifId)
        .get()
        .then((snapshot) {
      for (DocumentSnapshot ds in snapshot.docs) {
        ds.reference.set({'isDismissed': isDismissed}, SetOptions(merge: true));
      }
    });
    if (isDismissed == true) {
      _notificationIdsForDismissal.add(notifId);
      await Future.delayed(const Duration(seconds: 5), () {
        removeAllForDismissal;
      });
    } else {
      _notificationIdsForDismissal.remove(notifId);
    }
  }

  Future<void> dismissAll() async {
    await _firestoreDb
        .collection('notifications')
        .doc(_userUID)
        .collection('notification')
        .get()
        .then((snapshot) {
      for (DocumentSnapshot ds in snapshot.docs) {
        ds.reference.set({'isDismissed': true}, SetOptions(merge: true));
        _notificationIdsForDismissal.add(ds['id']);
      }
    });

    await Future.delayed(const Duration(seconds: 5), () {
      removeAllForDismissal;
      clearBadgeCount();
    });
  }

  Future<void> undoDismissAll() async {
    for (var notifId in _notificationIdsForDismissal) {
      await _firestoreDb
          .collection('notifications')
          .doc(_userUID)
          .collection('notification')
          .where('id', isEqualTo: notifId)
          .get()
          .then((snapshot) {
        for (DocumentSnapshot ds in snapshot.docs) {
          ds.reference.set({'isDismissed': false}, SetOptions(merge: true));
        }
      });
    }
    _notificationIdsForDismissal.clear();
  }

  Future<void> setAsRead(String notifId) async {
    await _firestoreDb
        .collection('notifications')
        .doc(_userUID)
        .collection('notification')
        .where('id', isEqualTo: notifId)
        .get()
        .then((snapshot) {
      for (DocumentSnapshot ds in snapshot.docs) {
        ds.reference.set({'isRead': true}, SetOptions(merge: true));
      }
    });
  }

  Future<void> setAllAsRead() async {
    await _firestoreDb
        .collection('notifications')
        .doc(_userUID)
        .collection('notification')
        .where('isRead', isEqualTo: false)
        .get()
        .then((snapshot) {
      for (DocumentSnapshot ds in snapshot.docs) {
        ds.reference.set({'isRead': true}, SetOptions(merge: true));
      }
    });
  }

  Future<void> removeAllForDismissal() async {
    for (var notifId in _notificationIdsForDismissal) {
      await _firestoreDb
          .collection('notifications')
          .doc(_userUID)
          .collection('notification')
          .where('id', isEqualTo: notifId)
          .get()
          .then((snapshot) {
        for (DocumentSnapshot ds in snapshot.docs) {
          ds.reference.delete();
        }
      });
    }
    _notificationIdsForDismissal.clear();
  }

  void getUnreadNotificationsCountFromStream(String userId) {
    FirebaseFirestore.instance
        .collection('notifications')
        .doc(userId)
        .collection('notification')
        .snapshots()
        .listen((QuerySnapshot snapshot) {
      _unreadCount = 0;
      if (snapshot.docs.isNotEmpty) {
        _hasNotification = true;
      } else {
        _hasNotification = false;
      }
      for (var doc in snapshot.docs) {
        if (doc.exists && doc['isRead'] == false) {
          _unreadCount++;
        }
      }

      updateBadgeCount(_unreadCount);

      debugPrint('unread count: $_unreadCount');
      notifyListeners();
    });
  }
}
